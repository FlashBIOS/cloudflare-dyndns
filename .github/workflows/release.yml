name: Create Release on Master Push

permissions:
  contents: write

on:
  push:
    branches: [ master ]

jobs:
  release:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v3

      - name: Set Up Go
        uses: actions/setup-go@v4
        with:
          go-version: '1.24'

      - name: Build Release Artifacts
        run: make release

      - name: Archive Binaries per OS/Arch
        env:
          BINARY_NAME: cloudflare-dyndns
        run: |
          for os in $(ls bin); do
            for arch in $(ls bin/$os); do
              if [ "$os" = "windows" ]; then
                echo "Archiving for $os $arch as zip"
                zip -j "${os}-${arch}.zip" "bin/$os/$arch/$BINARY_NAME"
              else
                echo "Archiving for $os $arch as tar.gz"
                tar -C "bin/$os/$arch" -czvf "${os}-${arch}.tar.gz" "$BINARY_NAME"
              fi
            done
          done

      # This step uses GitHub Script to query for the PRs associated with the head commit.
      - name: Get PR Messages
        id: pr_messages
        uses: actions/github-script@v6
        with:
          script: |
            // Get the head commit SHA and message from the push payload.
            const commitSha = context.payload.head_commit.id;
            const commitMessage = context.payload.head_commit.message;

            // Query the API for pull requests associated with that commit.
            const { data: pulls } = await github.rest.repos.listPullRequestsAssociatedWithCommit({
              owner: context.repo.owner,
              repo: context.repo.repo,
              commit_sha: commitSha,
              mediaType: {
                previews: ['groot']  // Required for this endpoint.
              }
            });

            let prNotes = '';
            if (pulls.length > 0) {
              prNotes = pulls.map(pr => {
                return `PR #${pr.number}: ${pr.title}\n${pr.body || ""}`;
              }).join("\n\n---\n\n");
            } else {
              prNotes = `No associated PRs found.\n\nCommit Message:\n${commitMessage}`;
            }
            core.info("Final release notes:\n" + prNotes);
            return prNotes;
          result-encoding: string

      - name: Create GitHub Release
        id: create_release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: "v${{ github.run_number }}"
          release_name: "Release ${{ github.run_number }}"
          body: |
            ${{ steps.pr_messages.outputs.result }}
          draft: false
          prerelease: false

      - name: Upload Release Assets
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Strip the templated part from the upload URL.
          upload_url="${{ steps.create_release.outputs.upload_url }}"
          upload_url="${upload_url%\{*}"

          # Loop over generated archives.
          for asset in *.tar.gz *.zip; do
            if [ -f "$asset" ]; then
              echo "Uploading $asset"
              if [[ "$asset" == *.zip ]]; then
                content_type="application/zip"
              else
                content_type="application/gzip"
              fi
              # URLâ€‘encode the asset name.
              encoded_name=$(python3 -c "import urllib.parse; print(urllib.parse.quote('''$asset'''))")
              curl --fail -X POST \
                -H "Authorization: token $GITHUB_TOKEN" \
                -H "Content-Type: ${content_type}" \
                --data-binary @"$asset" \
                "${upload_url}?name=${encoded_name}"
            fi
          done